---
description: 
globs: 
alwaysApply: true
---
These rules are specific to the `llmctx` project and should be followed to maintain consistency, modularity, and adherence to the established architecture.

## Core Principles

*   **Keep it clean, small, and swappable.**
*   **Pure core, thin edges, swap at the ports.**

---

## 1. Folder Layout & Structure

*   Adhere to the following folder structure for new modules and code:
    ```
    packages/
      core/          # Domain-only logic, no external dependencies except ports.
      ports/         # TypeScript interfaces for core and adapters.
      app/           # Use-case orchestration, depends on core and ports.
      adapters/      # Concrete implementations of ports, one folder per adapter. Depends on ports and external libraries.
      cli/           # Commander program and commands, depends on app.
    plugins/         # Third-party add-ons (auto-loaded).
    ```
*   Each folder under `packages/` should export a single `index.ts` barrel file.

---

## 2. Layer Rules (Hexagonal Architecture)

Enforce strict layer dependencies. Violations are checked by `dependency-cruiser` in CI.

*   **`core`**:
    *   May depend on: itself, `ports`.
    *   Must NOT depend on: `app`, `adapters`, external libraries.
*   **`app`**:
    *   May depend on: `core`, `ports`.
    *   Must NOT depend on: `adapters`, external libraries.
*   **`adapters`**:
    *   May depend on: `ports`, external libraries.
    *   Must NOT depend on: `core`.
*   **`cli` / `delivery`**:
    *   May depend on: `app`.
    *   Must NOT depend on: `core` internals, `adapters` internals.

---

## 3. Dependency Injection

*   Use `tsyringe` for dependency injection with a single, shared container instance.
*   The composition root is exclusively `packages/cli/index.ts`.
*   Register adapter implementations in `adapters/index.ts`.
    *   Example: `container.register<VectorStore>("VectorStore", { useClass: QdrantVectorStore });`
*   Prioritize swapping implementations via environment variables or plugins, without modifying `core` or `app` layers.

---

## 4. Configuration

*   Follow an `.env-first` approach for all configuration.
*   All environment variable parsing and validation must occur in `config/env.ts` (using `zod`).
*   For every new environment variable added:
    *   Update `.env.example` accordingly.
    *   Ensure it's parsed and validated in `config/env.ts`.
*   Example environment variables:
    *   `EMBED_MODEL`: (e.g., `openai`, `minilm`)
    *   `INDEX_VERSION`: (e.g., `v3`)
    *   `LOG_LEVEL`: (e.g., `debug`)

---
## 5. CLI Conventions

*   Use `Commander` as the facade for the CLI. The root command is `llmctx`.
*   Structure sub-commands to mirror use-cases.
    *   Example: `llmctx index [--changed-only]`
    *   Example: `llmctx query <text> [--filter k=v]`
    *   Example: `llmctx ast-info <file> <line> <char>`
*   CLI commands must return JSON output ONLY when the `--json` flag is present. Otherwise, use human-readable output.

---

## 6. Testing Strategy (Vitest)

*   Implement tests using Vitest with the following scope definitions:
    *   **Core/App**: Unit tests, using in-memory stubs/mocks.
    *   **Adapters**: Integration tests, typically involving Docker via `testcontainers`.
    *   **CLI**: End-to-end tests, primarily by snapshotting `stdout`.
*   Maintain a test coverage of at least 80%. This is enforced as a CI gate.
*   **For all new features** (functions, classes, methods, routes, etc.):
    *   Create comprehensive unit tests.
    *   Ensure tests cover:
        *   1 test for the expected/happy path use case.
        *   1 test for at least one relevant edge case.
        *   1 test for a potential failure case (e.g., invalid input, error handling).
*   After modifying any existing logic, review and update corresponding unit tests to reflect the changes.

---

## 7. Development Practices

*   Ensure all new files and code are placed in the correct layer and folder as per the defined architecture (Section 1 & 2).
*   Register any new adapter implementation in `adapters/index.ts` as per DI guidelines (Section 3).
*   (Conceptual) Before finalizing changes, ensure `pnpm lint && pnpm test` would pass.
*   When adding or modifying logging statements, use `pino` and include meaningful context fields to aid debugging.

---

## 8. Extending Extraction & Querying

### 8.1 Data-Extraction Pipeline

*   Pipeline stages must implement the `PipelineStage<Input, Output>` interface, typically located in `core/pipeline/`.
*   **Adding/Changing Validation:**
    1.  Create a pure validator stage.
        *   If no external libraries are needed: `core/validators/`.
        *   If external libraries are needed: `adapters/validators/`.
    2.  Register the new validator stage using `PipelineBuilder.use(new MyValidator())`. This registration should occur **only** within `app/indexCode` (or the relevant application use-case setup).
    3.  Make the validator togglable via an environment variable (e.g., `VALIDATORS=email,myCustomValidator`).
*   Validators must either enrich chunk metadata or throw a typed `ValidationError`. They must NOT have side effects.

### 8.2 Query-Side Extensions

*   All data retrieval logic must flow through the `IRetriever` port (interface).
*   Implement new query features (e.g., reranking, semantic filtering, summarization) as **decorators** that wrap a base `IRetriever` implementation.
    *   Example Structure:
        ```typescript
        export class RerankRetriever implements IRetriever {
          constructor(private baseRetriever: IRetriever) {} // Inject the retriever to wrap

          async search(query: Query): Promise<Result[]> {
            const baseResults = await this.baseRetriever.search(query);
            // ... apply reranking logic ...
            return rerankedResults;
          }
        }
        ```
*   Bind these decorator implementations via Dependency Injection in the composition root (`packages/cli/index.ts` via `adapters/index.ts`).
    *   Example: `container.register<IRetriever>("IRetriever", { useClass: RerankRetriever });`
*   If multiple retrieval strategies are available, expose them through a CLI flag (e.g., `--strategy rerank`) or an environment variable (e.g., `RETRIEVER_STRATEGY=rerank_summary`). 
